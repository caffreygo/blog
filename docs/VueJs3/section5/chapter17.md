# 编译优化

编译优化指的是编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程。编译优化的策略与具体实现是由框架的设计思路所决定的，不同的框架具有不同的设计思路，因此编泽优化的策略也不尽相同。

✅ 但优化的方向基本一致，即尽可能地区分动态内容利静态内容，并针对不同的内容采用不同的优化策略。

## 动态节点收集与补丁标志

### 传统 Dif 算法的问题

之前共介绍了三种关于传统虚拟 DOM 的 Diff 算法。但无论哪一种 Diff 算法，当它在比对新旧两棵虚拟 DOM 树的时候，总是要按照虚拟 DOM的层级结构**一层一层**地遍历。举个例子，假设我们有如下模板：

```html
<div id="foo">
  <p class="bar">
    {{ text }}
  </p>
</div>
```

在上面这段模板中，唯一可能变化的就是 p 标签的文本子节点的内容。也就是说，当响应式数据 `text` 的值发生变化时，最高效的更新方式就是直接设置 p 标签的文本内容。但传统 Diff 算法显然做不到如此高效，当响应式数据 `text` 发生变化时，会产生一棵新的虚拟 DOM 树，

::: tip 传统 Diff 算法对比新旧两棵虚拟 DOM树的过程如下：

1. 对比 div 节点，以及该节点的属性和子节点。
2. 对比 p 节点，以及该节点的属性和子节点。
3. 对比 p 节点的文本子节点，如果文本子节点的内容变了，则更新之，否则什么都不做。

可以看到，与直接更新 p 标签的文本内容相比，传统 Diff 算法存在很多**无意义的比对操作**。如果能够跳过这此无意义的操作，性能将会大幅提升。而这就是 vue.js3 编译优化的思路来源。

:::

实际上，模板的结构非常稳定。通过编译手段，我们可以分析出很多关键信息，例如哪些节点是静态的，哪些节点是动态的。结合这些关键信息，编译器可以直接生成原生 DOM 操作的代码，这样甚至能够抛弃掉虚拟 DOM，从而避免虚拟 DOM 带来的性能开销。但是，考虑到渲染函数的灵活性，以及 Vue js 2 的兼容题，vue.js 3 最终还是选择了保留虚拟 DOM。这样一来，就必然要面临它所带来的额外性能开销。

✅ 那么，为什么虛拟 DOM 会产生额外的性能开销呢？根本原因在于，渲染器在运行时得不到足够的信息。传统 Diff 算法无法利用编译时提取到的任何关键信息，这导致渲染器在运行时不可能去做相关的优化。而 Vue.js 3 的编译器会将编译时得到的**关键信息“附着”在它生成的虚拟 DoM上**，这些信息会通过虚拟 DOM 传递给渲染器。最终，渲染器会根据这些关键信息执行“快捷路径”，从而提升运行时的性能。
